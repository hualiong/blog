<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>【Java SE】六、字符串 | Hualiang&#39;s Blog</title>
<link rel="shortcut icon" href="https://hualiang.online/favicon.ico?v=1762159937976">
<link href="https://cdn.staticfile.net/remixicon/2.3.0/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://hualiang.online/styles/main.css">
<link rel="alternate" type="application/atom+xml" title="【Java SE】六、字符串 | Hualiang&#39;s Blog - Atom Feed" href="https://hualiang.online/atom.xml">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">



    <meta name="description" content="与 C 不同的是，Java 提供了 String ，StringBuilder ，StringBuffer 三个类来专门处理字符串，在 Java 中字符串属于对象，而不是基本数据类型之一。

String 类
创建字符串
创建字符串最简单的..." />
    <meta name="keywords" content="Java" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
    <script src="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.5.1/build/highlight.min.js"></script>
  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://hualiang.online">
  <img class="avatar" src="https://hualiang.online/images/avatar.png?v=1762159937976" alt="">
  </a>
  <h1 class="site-title">
    Hualiang&#39;s Blog
  </h1>
  <p class="site-description">
    <i>Unless I don't want to win, nobody can make me lose.</i><br/><br/>I always believe 天道酬勤
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu">
          标签
        </a>
      
    
  </div>
  <div class="social-container">
    
      
        <a href="https://github.com/hualiong" target="_blank">
          <i class="ri-github-line"></i>
        </a>
      
    
      
        <a href="https://twitter.com/huoliong" target="_blank">
          <i class="ri-twitter-line"></i>
        </a>
      
    
      
        <a href="https://weibo.com" target="_blank">
          <i class="ri-weibo-line"></i>
        </a>
      
    
      
        <a href="https://zhuanlan.zhihu.com" target="_blank">
          <i class="ri-zhihu-line"></i>
        </a>
      
    
      
        <a href="https://www.facebook.com" target="_blank">
          <i class="ri-facebook-line"></i>
        </a>
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              【Java SE】六、字符串
            </h2>
            <div class="post-info">
              <span>
                2023-01-25
              </span>
              <span>
                10 min read
              </span>
              
                <a href="https://hualiang.online/tag/6ysHJUyVK/" class="post-tag">
                  # Java
                </a>
              
            </div>
            
            <div class="post-content-wrapper">
              <div class="post-content" v-pre>
                <p>与 C 不同的是，Java 提供了 String ，StringBuilder ，StringBuffer 三个类来专门处理字符串，在 Java 中字符串属于对象，而不是基本数据类型之一。</p>
<!-- more -->
<h1 id="string-类">String 类</h1>
<h2 id="创建字符串">创建字符串</h2>
<p>创建字符串最简单的方式如下:</p>
<pre><code class="language-java">String str = &quot;Runoob&quot;;
</code></pre>
<p>这里的值是 &quot;Runoob&quot;，编译器会使用该值创建一个 String 对象。</p>
<p>和其它对象一样，可以使用关键字和构造方法来创建 String 对象：</p>
<pre><code class="language-java">String str2 = new String(&quot;Runoob&quot;);
</code></pre>
<p>String 创建的字符串存储在公共池中，而 <code>new</code> 创建的字符串对象在堆上：</p>
<pre><code class="language-java">String s1 = &quot;Runoob&quot;;              // String 直接创建
String s2 = &quot;Runoob&quot;;              // String 直接创建
String s3 = s1;                    // 相同引用
String s4 = new String(&quot;Runoob&quot;);   // String 对象创建
String s5 = new String(&quot;Runoob&quot;);   // String 对象创建
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://www.runoob.com/wp-content/uploads/2013/12/java-string-1-2020-12-01.png" alt="img" loading="lazy"></figure>
<p>String 类有 11 种构造方法，这些方法提供不同的参数来初始化字符串，比如提供一个字符数组参数:</p>
<pre><code class="language-java">public class StringDemo{
   public static void main(String args[]){
      char[] helloArray = { 'r', 'u', 'n', 'o', 'o', 'b'};
      String helloString = new String(helloArray);  
      System.out.println( helloString ); // 输出结果为：runoob
   }
}
</code></pre>
<p><strong>注意：<strong>String 类是不可改变的，它是</strong>字符串常量</strong>，所以你一旦创建了 String 对象，那它的值就无法改变了。</p>
<p>如果需要对字符串做很多修改，那么应该选择使用 <a href="https://www.runoob.com/java/java-stringbuffer.html">StringBuffer &amp; StringBuilder 类</a>。</p>
<h2 id="字符串长度">字符串长度</h2>
<p>String 类提供了一个 <code>length</code> 方法，用来返回字符串对象包含的字符数，如下所示:</p>
<pre><code class="language-java">public class StringDemo {
    public static void main(String args[]) {
        String site = &quot;www.runoob.com&quot;;
        int len = site.length();
        System.out.println( &quot;菜鸟教程网址长度 : &quot; + len ); // 输出结果为：菜鸟教程网址长度 : 14
   }
}
</code></pre>
<h2 id="连接字符串">连接字符串</h2>
<p>String 类提供了连接两个字符串的方法：</p>
<pre><code class="language-java">string1.concat(string2);
</code></pre>
<p>返回 <code>string2</code> 连接 <code>string1</code> 的新字符串。也可以对字符串常量使用 <code>concat</code> 方法，如：</p>
<pre><code class="language-java">&quot;我的名字是 &quot;.concat(&quot;Runoob&quot;); // &quot;我的名字是 Runoob&quot;
</code></pre>
<p>更常用的是使用'+'操作符来连接字符串，如：</p>
<pre><code class="language-java">&quot;Hello,&quot; + &quot; runoob&quot; + &quot;!&quot; // &quot;Hello, runoob!&quot; 
</code></pre>
<p>下面是一个例子:</p>
<pre><code class="language-java">public class StringDemo {
    public static void main(String args[]) {     
        String string1 = &quot;菜鸟教程网址：&quot;;     
        System.out.println(&quot;1、&quot; + string1 + &quot;www.runoob.com&quot;); // 输出结果为：1、菜鸟教程网址：www.runoob.com
    }
}
</code></pre>
<h2 id="创建格式化字符串">创建格式化字符串</h2>
<p>我们知道输出格式化数字可以使用 <code>printf</code> 和 <code>format</code> 方法。</p>
<p>String 类使用静态方法 <code>format</code> 返回一个 String 对象而不是 PrintStream 对象。</p>
<p>该静态方法能用来创建可复用的格式化字符串，而不仅仅是用于一次打印输出。</p>
<p>如下所示：</p>
<pre><code class="language-java">System.out.printf(&quot;%f, %d, %s&quot;, floatVar, intVar, stringVar);
</code></pre>
<p>你也可以这样写</p>
<pre><code class="language-java">String fs = String.format(&quot;%f, %d, %s&quot;, floatVar, intVar, stringVar);
</code></pre>
<h2 id="string-方法">String 方法</h2>
<p>下面是常用 String 类支持的方法，包含重载方法，更多详细请参看 <a href="https://www.runoob.com/manual/jdk11api/java.base/java/lang/String.html">Java String API</a> 文档：</p>
<table>
<thead>
<tr>
<th style="text-align:left">*</th>
<th style="text-align:left">方法描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left"><strong>char charAt(int index)</strong> 返回指定索引处的 char 值。</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left"><strong>String concat(String str)</strong> 将指定字符串连接到此字符串的结尾。</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left"><strong>boolean endsWith(String suffix)</strong> 测试此字符串是否以指定的后缀结束。</td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:left"><strong>boolean equals(Object anObject)</strong> 将此字符串与指定的对象比较。</td>
</tr>
<tr>
<td style="text-align:left">5</td>
<td style="text-align:left"><strong>void getChars(int srcBegin, int srcEnd, char dst, int dstBegin)</strong> 将字符从此字符串复制到目标字符数组。</td>
</tr>
<tr>
<td style="text-align:left">6</td>
<td style="text-align:left"><strong>int indexOf(int ch)</strong> 返回指定字符在此字符串中第一次出现处的索引。</td>
</tr>
<tr>
<td style="text-align:left">7</td>
<td style="text-align:left"><strong>int indexOf(int ch, int fromIndex)</strong> 返回在此字符串中第一次出现指定字符处的索引，从指定的索引开始搜索。</td>
</tr>
<tr>
<td style="text-align:left">8</td>
<td style="text-align:left"><strong>int indexOf(String str)</strong>  返回指定子字符串在此字符串中第一次出现处的索引。</td>
</tr>
<tr>
<td style="text-align:left">9</td>
<td style="text-align:left"><strong>int indexOf(String str, int fromIndex)</strong> 返回指定子字符串在此字符串中第一次出现处的索引，从指定的索引开始。</td>
</tr>
<tr>
<td style="text-align:left">10</td>
<td style="text-align:left"><strong>int lastIndexOf(int ch)</strong>  返回指定字符在此字符串中最后一次出现处的索引。</td>
</tr>
<tr>
<td style="text-align:left">11</td>
<td style="text-align:left"><strong>int lastIndexOf(int ch, int fromIndex)</strong> 返回指定字符在此字符串中最后一次出现处的索引，从指定的索引处开始反向搜索。</td>
</tr>
<tr>
<td style="text-align:left">12</td>
<td style="text-align:left"><strong>int lastIndexOf(String str)</strong> 返回指定子字符串在此字符串中最右边出现处的索引。</td>
</tr>
<tr>
<td style="text-align:left">13</td>
<td style="text-align:left"><strong>int lastIndexOf(String str, int fromIndex)</strong>  返回指定子字符串在此字符串中最后一次出现处的索引，从指定的索引开始反向搜索。</td>
</tr>
<tr>
<td style="text-align:left">14</td>
<td style="text-align:left"><strong>int length()</strong> 返回此字符串的长度。</td>
</tr>
<tr>
<td style="text-align:left">15</td>
<td style="text-align:left"><strong>boolean matches(String regex)</strong> 告知此字符串是否匹配给定的正则表达式。</td>
</tr>
<tr>
<td style="text-align:left">16</td>
<td style="text-align:left"><strong>String replace(char oldChar, char newChar)</strong> 返回一个新的字符串，它是通过用 newChar 替换此字符串中出现的所有 oldChar 得到的。</td>
</tr>
<tr>
<td style="text-align:left">17</td>
<td style="text-align:left"><strong>String replaceAll(String regex, String replacement)</strong> 使用给定的 replacement 替换此字符串所有匹配给定的正则表达式的子字符串。</td>
</tr>
<tr>
<td style="text-align:left">18</td>
<td style="text-align:left"><strong>String replaceFirst(String regex, String replacement)</strong> 使用给定的 replacement 替换此字符串匹配给定的正则表达式的第一个子字符串。</td>
</tr>
<tr>
<td style="text-align:left">19</td>
<td style="text-align:left"><strong>String[] split(String regex)</strong> 根据给定正则表达式的匹配拆分此字符串。</td>
</tr>
<tr>
<td style="text-align:left">20</td>
<td style="text-align:left"><strong>String[] split(String regex, int limit)</strong> 根据匹配给定的正则表达式来拆分此字符串。</td>
</tr>
<tr>
<td style="text-align:left">21</td>
<td style="text-align:left"><strong>boolean startsWith(String prefix)</strong> 测试此字符串是否以指定的前缀开始。</td>
</tr>
<tr>
<td style="text-align:left">22</td>
<td style="text-align:left"><strong>boolean startsWith(String prefix, int toffset)</strong> 测试此字符串从指定索引开始的子字符串是否以指定前缀开始。</td>
</tr>
<tr>
<td style="text-align:left">23</td>
<td style="text-align:left"><strong>String substring(int beginIndex)</strong> 返回一个新的字符串，它是从指定下标开始一直截取到字符串的最后。</td>
</tr>
<tr>
<td style="text-align:left">24</td>
<td style="text-align:left"><strong>String substring(int beginIndex, int endIndex)</strong> 返回一个新字符串，它是从前一个下标截取到后一个下标对应的元素。</td>
</tr>
<tr>
<td style="text-align:left">25</td>
<td style="text-align:left"><strong>char[] toCharArray()</strong> 将此字符串转换为一个新的字符数组。</td>
</tr>
<tr>
<td style="text-align:left">26</td>
<td style="text-align:left"><strong>String toLowerCase()</strong> 使用默认语言环境的规则将此 String 中的所有字符都转换为小写。</td>
</tr>
<tr>
<td style="text-align:left">27</td>
<td style="text-align:left"><strong>String toLowerCase(Locale locale)</strong> 使用给定 Locale 的规则将此 String 中的所有字符都转换为小写。</td>
</tr>
<tr>
<td style="text-align:left">28</td>
<td style="text-align:left"><strong>String toString()</strong> 返回此对象本身（它已经是一个字符串！）。</td>
</tr>
<tr>
<td style="text-align:left">29</td>
<td style="text-align:left"><strong>String toUpperCase()</strong> 使用默认语言环境的规则将此 String 中的所有字符都转换为大写。</td>
</tr>
<tr>
<td style="text-align:left">30</td>
<td style="text-align:left"><strong>String toUpperCase(Locale locale)</strong> 使用给定 Locale 的规则将此 String 中的所有字符都转换为大写。</td>
</tr>
<tr>
<td style="text-align:left">31</td>
<td style="text-align:left"><strong>String trim()</strong> 返回字符串的副本，忽略前导空白和尾部空白。</td>
</tr>
<tr>
<td style="text-align:left">32</td>
<td style="text-align:left"><strong>contains(CharSequence chars)</strong> 判断是否包含指定的字符系列。</td>
</tr>
<tr>
<td style="text-align:left">33</td>
<td style="text-align:left"><strong>isEmpty()</strong> 判断字符串是否为空。</td>
</tr>
</tbody>
</table>
<h2 id="stringbuffer-stringbuilder">StringBuffer &amp; StringBuilder</h2>
<p>当对字符串进行修改的时候，需要使用 StringBuffer 和 StringBuilder 类，它们能够被多次的修改，并且不产生新的未使用对象。</p>
<p>由于 StringBuilder 相较于 StringBuffer 有速度优势，所以多数情况下建议使用 StringBuilder 类。</p>
<pre><code class="language-java">public class Test {
    public static void main(String args[]) {
        StringBuilder sb = new StringBuilder(10); // 相当于创建一个长度为10的字符数组
        sb.append(&quot;Runoob..&quot;); // 追加
        System.out.println(sb);  
        sb.append(&quot;!&quot;);
        System.out.println(sb); 
        sb.insert(8, &quot;Java&quot;); // 利用索引插入
        System.out.println(sb); 
        sb.delete(5,8);
        System.out.println(sb); // 利用索引删除
    }
}
</code></pre>
<p>然而在应用程序要求线程安全的情况下，则必须使用 StringBuffer 类。</p>
<pre><code class="language-java">public class Test{
  public static void main(String args[]){
    StringBuffer sBuffer = new StringBuffer(&quot;菜鸟教程官网：&quot;);
    sBuffer.append(&quot;www&quot;);
    sBuffer.append(&quot;.runoob&quot;);
    sBuffer.append(&quot;.com&quot;);
    System.out.println(sBuffer);  
  }
}
</code></pre>
<p>以下是 StringBuffer 类支持的主要方法：</p>
<table>
<thead>
<tr>
<th style="text-align:left">*</th>
<th style="text-align:left">方法描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left"><strong>public StringBuffer append(String s)</strong> 将指定的字符串追加到此字符序列。</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left"><strong>public StringBuffer reverse()</strong>  将此字符序列用其反转形式取代。</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left"><strong>public delete(int start, int end)</strong> 移除此序列的子字符串中的字符。</td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:left"><strong>public insert(int offset, int i)</strong> 将 <code>int</code> 参数的字符串表示形式插入此序列中。</td>
</tr>
<tr>
<td style="text-align:left">5</td>
<td style="text-align:left"><strong>insert(int offset, String str)</strong> 将 <code>str</code> 参数的字符串插入此序列中。</td>
</tr>
<tr>
<td style="text-align:left">6</td>
<td style="text-align:left"><strong>replace(int start, int end, String str)</strong> 使用给定 <code>String</code> 中的字符替换此序列的子字符串中的字符。</td>
</tr>
</tbody>
</table>
<p>以下列表列出了 StringBuffer 类的其他常用方法：</p>
<table>
<thead>
<tr>
<th style="text-align:left">*</th>
<th style="text-align:left">方法描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left"><strong>int capacity()</strong> 返回当前容量。</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left"><strong>char charAt(int index)</strong> 返回此序列中指定索引处的 <code>char</code> 值。</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left"><strong>void ensureCapacity(int minimumCapacity)</strong> 确保容量至少等于指定的最小值。</td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:left"><strong>void getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin)</strong> 将字符从此序列复制到目标字符数组 <code>dst</code>。</td>
</tr>
<tr>
<td style="text-align:left">5</td>
<td style="text-align:left"><strong>int indexOf(String str)</strong> 返回第一次出现的指定子字符串在该字符串中的索引。</td>
</tr>
<tr>
<td style="text-align:left">6</td>
<td style="text-align:left"><strong>int indexOf(String str, int fromIndex)</strong> 从指定的索引处开始，返回第一次出现的指定子字符串在该字符串中的索引。</td>
</tr>
<tr>
<td style="text-align:left">7</td>
<td style="text-align:left"><strong>int lastIndexOf(String str)</strong> 返回最右边出现的指定子字符串在此字符串中的索引。</td>
</tr>
<tr>
<td style="text-align:left">8</td>
<td style="text-align:left"><strong>int lastIndexOf(String str, int fromIndex)</strong> 返回 String 对象中子字符串最后出现的位置。</td>
</tr>
<tr>
<td style="text-align:left">9</td>
<td style="text-align:left"><strong>int length()</strong> 返回长度（字符数）。</td>
</tr>
<tr>
<td style="text-align:left">10</td>
<td style="text-align:left"><strong>void setCharAt(int index, char ch)</strong> 将给定索引处的字符设置为 <code>ch</code>。</td>
</tr>
<tr>
<td style="text-align:left">11</td>
<td style="text-align:left"><strong>void setLength(int newLength)</strong> 设置字符序列的长度。</td>
</tr>
<tr>
<td style="text-align:left">12</td>
<td style="text-align:left"><strong>CharSequence subSequence(int start, int end)</strong> 返回一个新的字符序列，该字符序列是此序列的子序列。</td>
</tr>
<tr>
<td style="text-align:left">13</td>
<td style="text-align:left"><strong>String substring(int start)</strong> 返回一个新的 <code>String</code>，它包含此字符序列当前所包含的字符子序列。</td>
</tr>
<tr>
<td style="text-align:left">14</td>
<td style="text-align:left"><strong>String substring(int start, int end)</strong> 返回一个新的 <code>String</code>，它包含此序列当前所包含的字符子序列。</td>
</tr>
<tr>
<td style="text-align:left">15</td>
<td style="text-align:left"><strong>String toString()</strong> 返回此序列中数据的字符串表示形式。</td>
</tr>
</tbody>
</table>

              </div>
              <div class="toc-container">
                <ul class="markdownIt-TOC">
<li><a href="#string-%E7%B1%BB">String 类</a>
<ul>
<li><a href="#%E5%88%9B%E5%BB%BA%E5%AD%97%E7%AC%A6%E4%B8%B2">创建字符串</a></li>
<li><a href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%95%BF%E5%BA%A6">字符串长度</a></li>
<li><a href="#%E8%BF%9E%E6%8E%A5%E5%AD%97%E7%AC%A6%E4%B8%B2">连接字符串</a></li>
<li><a href="#%E5%88%9B%E5%BB%BA%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2">创建格式化字符串</a></li>
<li><a href="#string-%E6%96%B9%E6%B3%95">String 方法</a></li>
<li><a href="#stringbuffer-stringbuilder">StringBuffer &amp; StringBuilder</a></li>
</ul>
</li>
</ul>

              </div>
            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://hualiang.online/post/java-se-ming-ming-gui-ze/">
              <h3 class="post-title">
                【Java SE】五、命名规则
              </h3>
            </a>
          </div>
        

        

        <div class="site-footer">
  Powered by&nbsp;<a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>
  <a class="rss" href="https://hualiang.online/atom.xml" target="_blank">
    <i class="ri-rss-line"></i> RSS
  </a>
</div>

      </div>
    </div>

    <script>
      hljs.initHighlightingOnLoad()

      let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

      // This should probably be throttled.
      // Especially because it triggers during smooth scrolling.
      // https://lodash.com/docs/4.17.10#throttle
      // You could do like...
      // window.addEventListener("scroll", () => {
      //    _.throttle(doThatStuff, 100);
      // });
      // Only not doing it here to keep this Pen dependency-free.

      window.addEventListener("scroll", event => {
        let fromTop = window.scrollY;

        mainNavLinks.forEach((link, index) => {
          let section = document.getElementById(decodeURI(link.hash).substring(1));
          let nextSection = null
          if (mainNavLinks[index + 1]) {
            nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
          }
          if (section.offsetTop <= fromTop) {
            if (nextSection) {
              if (nextSection.offsetTop > fromTop) {
                link.classList.add("current");
              } else {
                link.classList.remove("current");    
              }
            } else {
              link.classList.add("current");
            }
          } else {
            link.classList.remove("current");
          }
        });
      });

    </script>
  </body>
</html>
